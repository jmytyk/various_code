known working stuff

open connection to micropython REPL via terraterm
115200 - 
maybe com 6?


# list root directory
print(os.listdir('/'))

# print current directory
print(os.getcwd())

--- 


http://docs.micropython.org/en/latest/esp8266/quickref.html

import machine
machine.freq() 

pin 2 is on board LED
 pin looks to be inverted - duty cycle of 1024 is off, 0 is on. 

 0-1023 is the range, it truncates the range if out of range. 

--- all works
from machine import Pin, PWM

pwm0 = PWM(Pin(0))      # create PWM object from a pin
pwm0.freq()             # get current frequency
pwm0.freq(1000)         # set frequency
pwm0.duty()             # get current duty cycle
pwm0.duty(200)          # set duty cycle
pwm0.deinit()           # turn off PWM on the pin

pwm2 = PWM(Pin(2), freq=500, duty=512) # create and configure in one go

--- the order of setting the freq and the duty matter -- set up the freq, then change up the duty cycle as needed. confirm on scope if this is the case -- ie, the duty doesn't change if the freq is changed afterwards. 

overwriting pin 1 will block serial connection back to you... oops.. 


#signal allows inversion.  pin 1 is hardware inverted, talking directly to pin 1, and watching the signal looks backwards, 
map the object connected to pin 1 over to the signal object, all set the invert value to true. 
when communicating to pin 1 via led2 (signal) - signal matches expection. 
led2_pin = Pin(1, Pin.OUT)
led2 = Signal(led2_pin, invert=True)

not sure how to link signal and pwm


//latest version - unknown if in sync.


#try pin d5, d6, which is GPIO 12 and 14 (used in spi)
#pwm2 --> pin2 is onboard LED

#import
#import machine   #imported by boot.py
from machine import PWM, Pin
from time import sleep
import math

#lut = [10, 15, 18, 50, 75, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]

def round_nearest_int(x):
    if x >= 0:
        return int(x + 0.5)
    else:
        return int(x - 0.5)


def fillCIETable():
    steps = 1024     #number of steps in the lut
    maxValue = 1024
    cie1931 = []    # pre-calculated PWM levels
  
    #scaling factor to convert from 0-100 to 0-maxValue:
    scalingFactor = 100 / maxValue
  
    #luminance value:
    Y = 0.0
  
    #iterate over the array and calculate the right value for it:
    for l in range(steps+1):
        # you need to scale L from a 0-255 range to a 0-100 range:
        lScaled = l * scalingFactor
        
        if lScaled <= 8:
            Y = (lScaled / 903.3)
        else:
            foo = (lScaled + 16) / 116.0
            Y = pow(foo, 3)
      
        #multiply to get 0-maxValue, and fill in the table:
        #cie1931.append(Y * maxValue)
        cie1931.append(round_nearest_int(Y * maxValue))      
      
    for value in cie1931:
        print(value)
  
    return cie1931


def convert(x, in_min, in_max, out_min, out_max):
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min



def main():
    
    lut = fillCIETable()
    
    #a way to scale all the values in the LUT
    min_brightness = 0
    max_brightness = 1024
    wait_at_top = 500
    wait_at_bottom = 500
    
    #led1 = Pin(0, Pin.OUT)
    led1 = Pin(12, Pin.OUT) #d6
    led2 = Pin(2, Pin.OUT)
    
    #pin setups
    pwm1 = PWM(led1, freq=500, duty=1023)
    pwm2 = PWM(led2, freq=500, duty=1023)
    
    #turn them off
    pwm1.duty(0)
    pwm2.duty(1023)
    
    #turn them on
    pwm1.duty(1023)
    pwm2.duty(0)

    while True:

        #fade up, 2 is inverted
        for value in lut:

            #map lut into min to max
            dcycle_value = round_nearest_int(convert(value, 0, 1024, min_brightness, max_brightness))

            print(dcycle_value)
            pwm1.duty(dcycle_value)
            pwm2.duty(dcycle_value)
            sleep(0.01)

        
        for i in range(wait_at_top):
            sleep(0.01)
            print("top...")
            
            
        #fade down, 2 is inverted. 
        for value in reversed(lut):

            #map lut into min to max
            dcycle_value = round_nearest_int(convert(value, 0, 1024, min_brightness, max_brightness))

            print(dcycle_value)
            pwm1.duty(dcycle_value)
            pwm2.duty(dcycle_value)

            sleep(0.01)

        #pausing for effect, printing something out to keep connection open
        for i in range(wait_at_bottom):
            sleep(0.01)
            print("bottom...")   

        print("end")
    

if __name__ == "___main___":
    main()




//
known good
d6 has 3.3v pwm, at 3.3v --> clean, responds to change
lvl shift, 3.3v tx1, -> 5.06v tx0 (far left of ch1 )  --> clean, repsonds to change.
with dimmer line in circuit -- very noisy --> 60hz?  --> driver block diagram?

wired in Arduino --> 5v pwm... super clean signal --> no change in output with COB, or 12v LED strip... driver is not dimming??

trying other driver. 
no change... no output change on LED strip


----fixed----
and... Vf -- LEDs have a minimum voltage that they turn on, and for this array, that voltage, clearly written on the data sheet is 18v, using a bench power supply, it was 13.6 volts, still above the 12v that i was feeding it with the wall wart. 

dimming works great, LED is hot!

next up, how many drivers can we drive with 1 controller?  -> going i2c breakout route.
-verifed driving 16 pwm channels via i2c break out works
-pwm level is not 5v, but logic 3.3v
-can level shift them up on output side. 

see if putting level shifter on i2c results in level shift on outputs?  - this is the ideal use case.
--> works! 


--sourced 10 drivers, and matching LEDs and holders - powering with DC 600w AC/DC PSU. 
--sourced level shifters as well, they are bi-directional, is that an issue? 

code is moved and generally rewritten to use the pwm board. 

test / map the LUT table formuala it may need to be modified from 0-255 to 0-4095 usage. 


need to work on the physical side of mounting and wiring 10 drivers, signal wires, power and such... 


what is the temperature of the LED after running for awhile?









